@using OnlineMongoMigrationProcessor
@using System.Text.RegularExpressions;

<div class="modal fade show d-block bg-dark bg-opacity-75" id="myModal" aria-modal="true" role="dialog">
    <div class="modal-dialog bg-dark">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title">Add/Remove Collections</h4>
                <button type="button" class="btn-close" aria-label="Close" @onclick="@Cancel"></button>
            </div>
            <div class="modal-body">
                <table class="table table-borderless">
                    <thead>
                        <tr>
                            <th>Collection</th>
                            <th>Action</th>
                        </tr>
                    </thead>
                    <tbody>
                        @foreach (var mu in LoadUpdatedMigrationUnits())
                        {
                            <tr>
                                <td>@mu.DatabaseName.@mu.CollectionName</td>
                                <td>
                                    <button class="btn btn-danger btn-sm" @onclick="() => RemoveCollection(mu)">Remove</button>
                                </td>
                            </tr>
                        }
                    </tbody>
                </table>

                <div class="mt-3">
                    <label for="nameSpaces" class="form-label">Collections To Add</label>
                    <textarea id="nameSpaces" @bind="newCollection" rows="4" placeholder="e.g. db1.col1,db1.col2,db2.col1,db2.col5 or CollectionInfo JSON format as described in readme" class="form-control" />
                    <button class="btn btn-primary btn-sm mt-2" @onclick="AddCollection">Add</button>
                </div>

                @if (collectionRemoved)
                {
                    <div class="alert alert-warning mt-2">If a collection is removed from the job, it will need to be migrated as new, and all migration and change stream details will be lost. Select Cancel if you wish to keep the collection.</div>
                }

                @if (!string.IsNullOrEmpty(errorMessage))
                {
                    <div class="alert alert-danger mt-2">
                        @errorMessage
                        <button type="button" class="btn-close btn-close-sm" aria-label="Close" @onclick="() => errorMessage = string.Empty"></button>
                    </div>
                }
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-primary" @onclick=@HandleSubmit>Ok</button>
                <button type="button" class="btn btn-secondary" @onclick="@Cancel">Cancel</button>
            </div>
        </div>
    </div>
</div>

@code
{
    [Parameter]
    public MigrationJob? MigrationJob { get; set; }

    [Parameter]
    public List<MigrationUnit>? MigrationUnits { get; set; }

    [Parameter]
    public EventCallback<List<MigrationUnit>?> OnCollectionsUpdated { get; set; }

    private string errorMessage = string.Empty;
    private string newCollection = string.Empty;
    private List<MigrationUnit> updatedMigrationUnits = new List<MigrationUnit>();
    private bool collectionRemoved = false;

    private List<MigrationUnit> LoadUpdatedMigrationUnits()
    {
        if (updatedMigrationUnits == null || updatedMigrationUnits.Count == 0)
        {
            updatedMigrationUnits = (MigrationUnits ?? new List<MigrationUnit>()).ToList();
        }

        return updatedMigrationUnits;
    }

    private void AddCollection()
    {
        errorMessage = string.Empty;
        if (!string.IsNullOrWhiteSpace(newCollection))
        {
            if (MigrationJob== null)
            {
                errorMessage = "MigrationJob is not set.";
                return;
            };

            Tuple<bool, string,string> retValue = Helper.ValidateNamespaceFormat(newCollection, MigrationJob.JobType);
            if (!retValue.Item1)
            {
                errorMessage = retValue.Item2;
                return;
            }

            var newunits = Helper.PopulateJobCollections(newCollection);            
            foreach (var mu in newunits)
            {
                updatedMigrationUnits.Add(mu);
            }

            newCollection = string.Empty;
        }
    }

    private void RemoveCollection(MigrationUnit mu)
    {
        errorMessage = string.Empty;
        if (updatedMigrationUnits.Count == 1)
        {
            errorMessage = "At least one collection is required for migration.";
            return;
        }
        updatedMigrationUnits.Remove(mu);
        collectionRemoved = true;
    }

    private void HandleSubmit()
    {
        if (OnCollectionsUpdated.HasDelegate)
        {
            OnCollectionsUpdated.InvokeAsync(updatedMigrationUnits);
        }
    }

    private void Cancel()
    {
        if (OnCollectionsUpdated.HasDelegate)
        {
            OnCollectionsUpdated.InvokeAsync(null);
        }
    }
}
